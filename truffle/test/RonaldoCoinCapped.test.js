/**
 *
 * autogenerated by solidity-visual-auditor
 *
 * execute with:
 *  #> truffle test <path/to/this/test.js>
 *
 * */
const Web3 = require("web3");
const truffleAssert = require("truffle-assertions");
const RonaldoCoinCapped = artifacts.require("RonaldoCoinCapped");
const web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:9545"));

const convertToDecimal = (n) => {
  return (n * 10 ** 18).toString();
};

const RonaldoCoinPrice = (0.0001).toString();

contract("RonaldoCoinCapped", (accounts) => {
  const creatorAddress = accounts[0];
  const firstOwnerAddress = accounts[1];
  const secondOwnerAddress = accounts[2];
  const thirdOwnerAddress = accounts[3];
  const fourthOwnerAddress = accounts[4];
  const externalAddress = accounts[5];
  /* create named accounts for contract roles */
  let ronaldoCoinCappedInstance;

  before(async () => {
    /* before tests */
    // positive test 1

    // this is not the constructor call
    // **deployer.deploy()** function in **2_deploy_contracts.js** is where the SC is deployed
    ronaldoCoinCappedInstance = await RonaldoCoinCapped.deployed();
    assert(
      ronaldoCoinCappedInstance !== undefined,
      "RonaldoCoinCapped contract should be deployed properly"
    );
  });
  context("checking totalTokenOfCreator...", () => {
    it("checking totalTokenOfCreator", async () => {
      const totalTokenOfCreator = await ronaldoCoinCappedInstance.balanceOf(
        creatorAddress
      );
      console.log(totalTokenOfCreator.toString(), "totalTokenOfCreator in original instance");
    });
  });
  beforeEach(async () => {
    /* before each context */
  });

  context("testgroup - security tests - description...", () => {
    let newRonaldoCoinCapped;
    //deploy a new contract
    before(async () => {
      /* before tests */
      newRonaldoCoinCapped = await RonaldoCoinCapped.new("RonaldoCoin", "RON");
    });

    beforeEach(async () => {
      /* before each tests */
    });

    afterEach(async () => {
      /* after each tests */
      //   console.log(await newRonaldoCoinCapped.totalSupply());
    });

    it("name and symbol check ...", async () => {
      assert.equal(await newRonaldoCoinCapped.name(), "RonaldoCoin");
      assert.equal(await newRonaldoCoinCapped.symbol(), "RON");
    });

    it("checking if 10 RON has been minted or not", async () => {
      const totalTokenOfCreator = await newRonaldoCoinCapped.balanceOf(
        creatorAddress
      ); // no need for toString(), as js keeps the returns as a object

      assert.equal(totalTokenOfCreator, convertToDecimal(10));
    });

    it("buying 1 RonaldoCoin from creatorAddress", async () => {
      // we need to use sendTransaction() as we're sending transaction to the contract
      // and not call newRonaldoCoinCapped.receive() directly
      const txnRes = await newRonaldoCoinCapped.sendTransaction({
        from: firstOwnerAddress,
        value: web3.utils.toWei(RonaldoCoinPrice, "ether")
      });

      await truffleAssert.eventEmitted(txnRes, "Transfer", (event) => {
        // since numeric values in javascript do not have enough precision they are wrapped in an BN object. We can use those BN methods.
        // see BN docs: https://github.com/indutny/bn.js/#utilities
        // console.log(RonaldoCoinPrice,"RonaldoCoinPrice");
        return (
          event._from == creatorAddress &&
          event._to == firstOwnerAddress &&
          event._value.toString() == convertToDecimal(1) // can't do toNumber() as js can't hold numbers that big
        );
      });

      const totalTokenOfCreator = await newRonaldoCoinCapped.balanceOf(
        creatorAddress
      ); // no need for toString(), as js keeps the returns as a object
      const totalTokenOfFOwner = await newRonaldoCoinCapped.balanceOf(
        firstOwnerAddress
      ); // no need for toString(), as js keeps the returns as a object

      // console.log(totalTokenOfCreator.toString(), "totalTokenOfCreator");
      assert.equal(totalTokenOfCreator, convertToDecimal(9));
      assert.equal(totalTokenOfFOwner, convertToDecimal(1));
    });
  });
});
